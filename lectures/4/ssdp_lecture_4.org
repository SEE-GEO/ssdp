#+TITLE: Scientific Software Development with Python
#+SUBTITLE: DevOps 2: Documentation and Continuous Integration
#+AUTHOR: Simon Pfreundschuh
#+OPTIONS: H:2 toc:nil
#+LaTeX_HEADER: \institute{Department of Space, Earth and Environment}
#+LaTeX_HEADER: \setbeamerfont{title}{family=\sffamily, series=\bfseries, size=\LARGE}
#+LATEX_HEADER: \usepackage[style=authoryear]{biblatex}
#+LATEX_HEADER: \usepackage{siunitx}
#+LaTeX_HEADER: \usetheme{chalmers}
#+LATEX_HEADER: \usepackage{subcaption}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{dirtree}
#+LATEX_HEADER: \usemintedstyle{monokai}
#+LATEX_HEADER: \usepackage{pifont}
#+LATEX_HEADER: \definecolor{light}{HTML}{CCCCCC}
#+LATEX_HEADER: \definecolor{dark}{HTML}{353535}
#+LATEX_HEADER: \definecolor{source_file}{rgb}{0.82, 0.1, 0.26}
#+LATEX_HEADER: \newcommand{\greencheck}{{\color{green}\ding{51}}}
#+LATEX_HEADER: \newcommand{\redcross}{{\color{red}\ding{55}}}
#+LATEX_HEADER: \newcommand{\question}{{\color{yellow}\textbf{???}}}
#+LATEX_HEADER: \addbibresource{literature.bib}
#+BEAMER_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Agenda}\tableofcontents[currentsection]\end{frame}}

* Introduction

** Lecture content
\centering
\includegraphics[width=0.6\textwidth]{figures/dimensions_of_software_development}

** Lecture content
\centering
\includegraphics[width=0.6\textwidth]{figures/dimensions_of_software_development_this}

** Lecture content
*** This lecture
      - Documentation with Sphinx
      - Continuous integration with GitHub

** Before we start
*** Nature Astronomy: The climate issue
    - In Australia emissions from super computers stand for
      largest part of $CO_2$ emissions
    - Running calculations in pure Python emits much more $CO_2$
      than when written in low-level language
*** Flaws in argumentation
    - Emissions in Australia depend on energy mix
    - Heavy calculations running on supercomputers are already
      not using Python
    - Emissions from personal computers much lower than from compute clusters
    - False dilemma: You should combine programming languages to get
      the best of both worlds

** Before we start
*** Nature Astronomy: The climate issue

    \includegraphics[width=0.6\textwidth]{figures/pp_0}

** Before we start
*** Nature Astronomy: The climate issue

    \includegraphics[width=0.6\textwidth]{figures/pp_1}

** Before we start
*** Nature Astronomy: The climate issue

    \includegraphics[width=0.6\textwidth]{figures/pp_2}

** Execise 1

   - Complete exercise 1 on task sheet.
   - Time: 10 minutes.

* Documentation
** Documentation
*** Purposes
    1. Communication with users
    2. Communication between developers
*** Types of documentation
    - Problem-oriented (How?):
      - User guide
    - Information-oriented (What?)
      - Source-code documentation

** Documentation
*** Publishing documentation
    - In principle, publishing documentation makes only sense for code that is
      intended to be used by others (interfaces)
    - \textbf{But:} Python makes it very easy to reuse functions from arbitrary
      modules
    - Small- and medium-sized projects: Makes sense to publish all documentation
      in single document.
      - Keeping everything in one place makes it easier to keep things up to date.
      - Examples can serve as integration tests, which will keep them from becoming
        outdated

** Documentation with Sphinx
*** Sphinx
   - Originally developed for the Python documentation
   - Install using =pip=:
    #+attr_latex: :options bgcolor=light, fontsize=\scriptsize
    #+BEGIN_SRC bash
    $ pip install sphinx
    #+END_SRC

** Documentation with Sphinx
*** How it works:
    - Write documentation using ReStructuredText (=*.rst=) markup language
    - Sphinx defines special directives that allow cross references between
      files.
    - Build documentation in desired output format (HTML, PDF, ...)

** Documentation with Sphinx
*** Typical folder structure
  @@latex:\dirtree{.1 project\_dir/. .2 module/. .3 \_\_init\_\_.py. .2 test/. .3 test\_module.py. .2 docs. }@@

*** Getting started
    #+attr_latex: :options bgcolor=light, fontsize=\scriptsize
    #+BEGIN_SRC bash
    $ cd docs
    $ sphinx-quickstart
    #+END_SRC

** Documentation with Sphinx
*** Minimal setup
    - Generated by =sphinx-quickstart=:

  @@latex:\dirtree{.1 project\_dir/. .2 module/. .3 \_\_init\_\_.py. .2 test/. .3 test\_module.py. .2 docs. .3 Makefile. .3 source/. .4 conf.py. .4 index.rst. .3 build/. }@@

** Documentation with Sphinx
*** Minimal setup
    - I recommend separating source and build path for docs
    - =source/conf.py=: Python source file to configure documentation
      settings
    - =source/index.rst=: Root document for documentation
    - =Makefile=: Makefile to build documentation

** Documentation with Sphinx

*** The default =index.rst=

    #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
    #+BEGIN_SRC rst

  .. weather_app documentation master file, created by
    sphinx-quickstart on Sat Sep 19 08:20:42 2020.
    You can adapt this file completely to your liking, but it should at least
    contain the root `toctree` directive.

  Welcome to weather_app's documentation!
  =======================================

  .. toctree::
    :maxdepth: 2
    :caption: Contents:



  Indices and tables
  ==================

  * :ref:`genindex`
  * :ref:`modindex`
  * :ref:`search`

  #+END_SRC

** Documentation with Sphinx

*** The generated =index.html=
    \includegraphics[width=\textwidth]{figures/sphinx_example}

    - Not much to see, so far
** Documentation with Sphinx
*** ReStructuredText

    #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
    #+BEGIN_SRC rst

    A section heading
    =================

    A subsection heading
    ---------------------

    A subsubsection heading
    ^^^^^^^^^^^^^^^^^^^^^^^

    *Italics*, **Bold**, ``code``
    
    * A bullet ...
    * ... list
    
    1. A numbered ...
    2. ... list

    # Also a numbered ...
    # ... list

    Good to know: Paragraphs must always start on the same indentation
    level.

  #+END_SRC

** Documentation with Sphinx

*** Directives

    - General syntax:
    #+attr_latex: :options fontsize=\scriptsize, style=manni, bgcolor=light
    #+BEGIN_SRC rst
    .. directive_name:: argument_1 ...
       :option_1: value_1
       :option_2: value_2

       Content ...
    #+END_SRC
    - Option directly follow directive declaration
    - Blank line to separate options from content
    - Content must be on same indentation level as options
    

** Documentation with Sphinx

*** The =toctree= directive


    #+attr_latex: :options fontsize=\scriptsize, style=manni, bgcolor=light
    #+BEGIN_SRC rst
    .. toctree::
      :maxdepth: 2
      :caption: Contents:

      file_1
      file_2
    #+END_SRC

    - Links content from other =.rst= files
    - Content should be list of =.rst= filenames without the file ending
    - Depth option determines up to which header levels should be listed
    

** Documentation with Sphinx

*** The =code-block= directive


    #+attr_latex: :options fontsize=\scriptsize, style=manni, bgcolor=light
    #+BEGIN_SRC rst

    - Used to display code in documentation
    .. code-block:: python

      def say_hi():
          print("hi")

    #+END_SRC

    - Expects name of language as argument


** Documentation with Sphinx
*** Building the documentation

    - To build HTML documentation in =build= folder:

    #+attr_latex: :options fontsize=\scriptsize, style=manni, bgcolor=light
    #+BEGIN_SRC bash

    $ cd docs
    $ make html

    #+END_SRC
** Documentation with Sphinx


*** Extended =index.rst=


    #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
    #+BEGIN_SRC rst
    The weather_app package
    =======================

    The ``weahter_app`` Python package provides a Python API to access the current
    SMHI weather forecast as well as a command line application to check the
    forecast for the next 24 hours at your location in Sweden.


    .. toctree::
      :maxdepth: 2
      :caption: Contents:

      installation
      usage
      api_reference

    Indices and tables
    ==================

    * :ref:`genindex`
    * :ref:`modindex`
    * :ref:`search`
    #+END_SRC

    - Expects name of language as argument

** Documentation with Sphinx

*** The generated =index.html=
    \includegraphics[width=0.8\textwidth]{figures/sphinx_example_2}


    

** Execise 2

   - Complete exercise 2 on task sheet.
   - Time: 15 minutes.

**  Documentation with Sphinx
*** Including Python docstrings
    - Sphinx provides the =autodoc= extension to automatically include docstrings
    - The =napoleon= extension allows using Google and numpy docstrings, which are
      much are easier to read and write then plain =.rst=.
    - In =conf.py=:

    #+attr_latex: :options fontsize=\scriptsize, bgcolor=dark
    #+BEGIN_SRC Python
      ...
      # Add any Sphinx extension module names here, as strings. They can be
      # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom 
      # ones.
      extensions = [ 'sphinx.ext.autodoc', 'sphinx.ext.napoleon' ] ...
      ...
    #+END_SRC

**  Documentation with Sphinx
*** To include docstrings from module
    - Need to create =*.rst= file and reference it from other document
    - Use =automodule= directive to include docstrings from whole module.
    - In =*.rst= file:

      #+attr_latex: :options fontsize=\scriptsize, bgcolor=light, style=manni
      #+BEGIN_SRC rst
      .. automodule:: weather_app.api
        :members:
      #+END_SRC
**  Documentation with Sphinx
*** Including docstrings
    - =autodoc= provides more directives for more fine-grained control
    - Process is semi-automatic: Need to create files for all modules
    - Can be automated using =sphinx-apidoc= command

** Execise 3

   - Complete exercise 3 on task sheet.
   - Time: 15 minutes.

** Hosting documentation on GitHub
*** GitHub Pages
    - Simple web hosting service for GitHub repositories
    - Hosts static web page locates in =docs= folder or specific branch
      called =gh-pages=

** Hosting documentation on GitHub
*** Example workflow
    - Generate documentation
    - Push generated documents to =gh-pages= branch
*** Things to consider
    - Don't want to keep track of history
    - Need to make sure all files are included
    - Need =.nojekyll= to tell GitHub to use Sphinx's =.css= files.

** Hosting documentation on GitHub
*** Example workflow
    #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
    #+BEGIN_SRC bash
    git branch -d gh-pages         # Delete branch if exists
    git checkout --orphan gh-pages # Use --orphan to discard history
    git rm -rf .                   # Removes staged files contained in branch
    cp -r docs/build/html/* .      # Copy generated documentation
    touch .nojekyll                # Create .nojekyll file
    git add *.html *.js *.inv _static _sources .nojekyll
    git commit
    git push -u <remote-name>
    #+END_SRC

    - Need to make sure GitHub pages service is activated for repository
    - Documentation available at =<user_name>.github.io/<repository_name>=

** Hosting documentation
*** Read the docs
    - Online service to automatically build and host Sphinx documentation
    - Automatic versioning
    - Popular

** Summary
   - Sphinx is de-facto standard for Python documentation
   - Can be used both for user-facing documentation
     and developer documentation

* Continuous Integration

** Continuous Integration
*** DevOps so far:
    - Steps required to integrate code changes:
      - Testing
      - Packaging
      - Generating documentation

   \begin{alertblock}{Problem}
   These are too many manual steps. How can we assure that
   we perform them every time?
   \end{alertblock}

** Continuous Integration
*** Continuous integration (CI)
    - Regularly integrate and release code changes
    - Advantages:
      - Flexibility: Respond to changing requirements
      - Reactiveness: Being able to fix things quickly
      - Learning: Direct feedback ensure learning from mistakes

   \begin{alertblock}{}
   The key to continuous integration is automating all manual DevOps
   steps.
   \end{alertblock}

** Continuous Integration
*** Continuous integration with GitHub
    - GitHub offers free CI functionality
    - Other services/products: Jenkins, Travis
      - Functionality is similar
    - Principle:
      - Define workflow to automate with special file in repository
      - Workflow is executed in the cloud and results are accessible
        through we interface

** Continuous Integration with GitHub
*** Workflows and actions
    - Workflow: Sequences of steps executed on a given event (e. g. push)
    - Actions:
      - Steps executed in workflow
      - Can be parametrized and reused, there's even a "marketplace" for them
    - Actions and workflows can be defined within the repository:

  @@latex:\dirtree{.1 project\_dir/. .2 .github/. .3 actions. .4 action.yml. .3 workflows. .4 workflow.yml. }@@

** Continuous Integration with GitHub
*** Workflow example
    - File: =.github/workflows/install_and_test.yml=

    #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
    #+BEGIN_SRC yaml
      name: install_and_test
      on: [push]
      jobs:
        install_job:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v2
              with:
                ref: 'main'
            - uses: actions/setup-python@v2
              with:
                python-version: '3.6'
            - run: pip install .
            - run: pip install pytest
            - run: pytest test/
    #+END_SRC

** Continuous Integration with GitHub
*** Workflow example
    - Runs whenever code is pushed to repository
    - Runs on server with latest ubuntu
    - Executed steps:
      1. Checkout latest changes from repository (Predefined action)
      2. Setup Python on server (Predefined action)
      3. Install the package
      4. Install pytest
      5. Run tests

** Continuous Integration with GitHub
*** Testing in different environments

    #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
    #+BEGIN_SRC yaml
  name: install_and_test
  on: [push]
  jobs:
    install_job:
      strategy:
        matrix:
          os: [ubuntu-latest, windows-latest, macos-latest]
          python: [3.6, 3.8]
      runs-on: ${{ matrix.os }}
      steps:
        - uses: actions/checkout@v2
          with:
            ref: 'main'
        - uses: actions/setup-python@v2
          with:
            python-version: ${{ matrix.python }}
        - run: pip install .
        - run: pip install pytest
        - run: pytest test/
    #+END_SRC

** Continuous Integration with GitHub

    #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
    #+BEGIN_SRC yaml
    ...
      strategy:
        matrix:
          os: [ubuntu-latest, windows-latest, macos-latest]
          python: [3.6, 3.8]
    ...
      runs-on: ${{ matrix.os }}
    ...
        - uses: actions/setup-python@v2
          with:
            python-version: ${{ matrix.python }}
    #+END_SRC

*** Testing in different environments
    - Define strategy matrix:
      - =variable: [values, ...]=
    - Access variable values using ={{ matrix.variable }}=
    - Different job launched for each combination of variable values

** Continuous Integration with GitHub
*** Testing in different environments
    
    \includegraphics[width=\textwidth]{figures/gh_example}

** Continuous Integration with GitHub
*** Adding a test badge to your repository page
    - GitHub provides badge graphics showing the status for every workflow
      under the URL:
      #+attr_latex: :options fontsize=\scriptsize, style=manni
      #+BEGIN_SRC bash
        https://github.com/<username>/<repository>/workflows/<name>/badge.svg
      #+END_SRC
    - Can be embedded in =README.md=  which is rendered on the front page
      of your repository:

      #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
      #+BEGIN_SRC bash
      ![workflow name](https://github.com/<username>/<repository>/workflows/<name>/badge.svg)
      #+END_SRC

** Continuous Integration with GitHub
*** Uploading distribution packages to PyPI
    - Problem:
      + Need username and password to upload to PyPI
      + \textbf{Repository is public, so can't want to store sensitive data there}
    - Solution:
      - GitHub secrets: Stores sensitive data in encrypted form to be accessed from
        within workflows
      - API Token: Unique identifier that GitHub can use to 

** Continuous Integration with GitHub
*** Uploading distribution packages to PyPI
    - Steps:
      - Generate API token on pypi.org
        - Account settings -> Add API token
      - Store API token as secret in your GitHub repository
        - Repository settings -> secrets -> new secret
        - Use secret in workflow ={{ secret.name }}=

** Continuous Integration with GitHub
*** Example workflow

#+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
#+BEGIN_SRC yaml
  name: release
  on:
    push:
      tags:
        - '*'
  jobs:
    release_job:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v2
          with:
            ref: 'main'
        - uses: actions/setup-python@v2
          with:
            python-version: '3.8'
        - run: pip install .
        - run: pip install wheel twine
        - run: python setup.py sdist bdist_wheel
        - run: python -m twine upload -u __token__ -p ${{ secrets.TWINE_TOKEN }} dist/*
#+END_SRC

** Continuous Integration with GitHub
*** Example workflow
    - PyPI requires all binaries to have unique versions, so you can't release everything
      that you push
    - Better policy is to release when a tag is pushed to the repository
    - Tags are named references to specific revisions of the repository:

      #+attr_latex: :options fontsize=\tiny, style=manni, bgcolor=light
      #+BEGIN_SRC bash
        git tag -a v0.0.1 # Mark current version with a name
        git push origin v0.0.1 # Push tag to GitHub
      #+END_SRC

** Summary
   - CI requires automation of all relevant DevOps tasks
   - Basic CI functionality provided by GitHub even for free
     accounts
